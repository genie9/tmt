multipl free zero decomposit algorithm known major difficulti comput zero decomposit occurr larg polynomi caus main multipl polynomi due reason even procedur comput one triangular set call well order procedur exponenti complex known cs method order overcom difficulti introduc zero decomposit algorithm addit polynomi use show well order procedur multipl free algorithm polynomi time complex input polynomi fix degre algorithm key idea algorithm avoid polynomi multipl pseudo remaind reduc initi polynomi step algorithm tdtriset repeat use polynomi follow result lemma let polynomi class initi proof case pseudo remaind need addit lemma follow formula direct base idea algorithm tdtriset modifi follow multipl free mf well order procedur comput triangular set algorithm — mftriset input finit set polynomi output monic triangular set set polynomi system set set return let polynomi highest class let dolet let polynomi lowest degre return step use formula split polynomi set algorithm mftriset easili give multipl free zero decomposit algorithm need replac algorithm tdtriset algorithm mftriset algorithm tdcs call algorithm mfcs algorithm — mfcs input finit set polynomi output monic proper triangular set satisfi properti theorem set choos polynomi set let input mftriset let output set return remark follow analyz complex algorithm mftriset basic show size polynomi bound size input polynomi worst case complex algorithm rough second result impli fix say algorithm mftriset polynomi time algorithm note solv quadrat boolean equat np complet algorithm mfcs number branch could exponenti discuss control number branch section bitsiz bound polynomi mftriset order estim size polynomi introduc bitsiz measur polynomi let monomi length denot defin k special length defin polynomi monomi call length first note sinc algorithm mfcs multipl free degre polynomi occur algorithm bound consequ size polynomi occur algorithm bound size polynomi effect control small exampl section rang exampl polynomi size largest possibl polynomi variabl size follow theorem show size polynomi algorithm mftriset effect control case theorem let number variabl input algorithm mftriset polynomi occur algorithm mftriset exist polynomi result nontrivi repeat addit polynomi increas size polynomi exponenti factor proof result quit complic intuit want show polynomi use earli step algorithm “canceled” later step addit two polynomi contain order prove theorem need prove sever lemma first let integ polynomi write univari polynomi defin two oper follow follow lemma lemma let polynomi otherwis proof easi check note defin composit natur let lemma let polynomi fix proof polynomi therefor henc case proof theorem assum th round mftriset deal polynomi class algorithm mftriset comput pseudo remaind two polynomi th round set initi first comput new polynomi thus polynomi th round obtain three way input polynomi round polynomi round case bigger still regard polynomi round way repres oper polynomi round call backtrack represent consid polynomi round get backtrack represent lemma get represent composit oper polynomi round process recurs process comput backtrack represent meet input polynomi stop repres polynomi one higher round last backtrack round elimin term compos oper polynomi note polynomi round input set composit oper input polynomi class appear due equat lemma number differ polynomi equat denot give upper bound easi see backtrack round exist two differ polynomi suppos backtrack round differ polynomi represent form polynomi form input polynomi thus other repres fix polynomi polynomi therefor number differ polynomi represent round henc backtrack round sinc lemma suppos form b suppos represent equat easi see exist term form input polynomi class polynomi without constant term therefor henc mean polynomi without constant term thus sum term equat obvious summari alway follow result show even size monomi occur algorithm nice bound corollari let set distinct monomi contain polynomi occur algorithm mftriset input algorithm proof proof theorem polynomi occur algorithm mftriset must form monomi must either contain input polynomi class thus bigger sum length lemma consid input polynomi get corollari complex analysi mftriset polynomi set defin highest total degre element section alway consid boolean polynomi set polynomi theorem input polynomi set bitsiz complex mftriset bitsiz complex mftriset consequ algorithm mftriset polynomi time algorithm small exampl section rang exampl complex sinc rough prove theorem rest section section assum th round mftriset start step deal polynomi class worst case suppos polynomi class th round sinc complex comput smaller polynomi addit consid addit two polynomi need polynomi addit order elimin thus estim number polynomi everi round obtain complex bound mftriset note step mftriset choos lowest degre import complex analysi suppos polynomi set class worst case elimin obtain two set polynomi fix polynomi lowest degre oper defin note moreov elimin four polynomi set similar sinc polynomi lowest degre mean two set conclud recurs follow sequenc set deduc number therefor number occur subscript consequ round correspond th part sequenc number thus number polynomi round impli need polynomi addit algorithm easi prove simpler case time addit still bound let us estim complex polynomi addit mftriset defin oper follow easi prove substitut equat equat section two equat either unchang becom plus one use denot number monomi occur similar proof theorem prove follow lemma lemma let number variabl input algorithm mftriset polynomi occur mftriset exist polynomi note bitsiz complex comput sum complex algorithm mftriset prove theorem
